# 如何写redis的mock
对于一个只有几个函数的interface{}，手写一个mock是很容易的，但是如果函数非常多，比如这[redis客户端](https://github.com/go-redis/redis)的接口UniversalClient，有一百多个函数。
```
type UniversalClient interface {
	Cmdable
	Watch(fn func(*Tx) error, keys ...string) error
	Process(cmd Cmder) error
	WrapProcess(fn func(oldProcess func(cmd Cmder) error) func(cmd Cmder) error)
	Subscribe(channels ...string) *PubSub
	PSubscribe(channels ...string) *PubSub
	Close() error
}

type Cmdable interface {
	Pipeline() Pipeliner
	Pipelined(fn func(Pipeliner) error) ([]Cmder, error)

	TxPipelined(fn func(Pipeliner) error) ([]Cmder, error)
	TxPipeline() Pipeliner

	Command() *CommandsInfoCmd
	ClientGetName() *StringCmd
	Echo(message interface{}) *StringCmd
	Ping() *StatusCmd
	Quit() *StatusCmd
	Del(keys ...string) *IntCmd
	
	//这里省略100多行
}
```
手写一个实现上面所有函数的mock是很费力的。幸运的go官方的提供了一个[mock](https://github.com/golang/mock)框架，上一节末尾我们也提到了，它就是专门用来解决这问题的。把这个库的代码下载到本地，编译出一个工具mockgen，使用这个工具可以从一个interface{}生成它对应的mock代码，这样就不用手写每个函数了。
命令如下：
```
mockgen -destination mock/mock_redis.go -package mock github.com/go-redis/redis UniversalClient
```

生成的文件如下，有3700多行，这里只显示一部分，随意感受一下
```
// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/go-redis/redis (interfaces: UniversalClient)

// Package mock is a generated GoMock package.
package mock

import (
	redis "github.com/go-redis/redis"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
	time "time"
)

// MockUniversalClient is a mock of UniversalClient interface
type MockUniversalClient struct {
	ctrl     *gomock.Controller
	recorder *MockUniversalClientMockRecorder
}

// MockUniversalClientMockRecorder is the mock recorder for MockUniversalClient
type MockUniversalClientMockRecorder struct {
	mock *MockUniversalClient
}

// NewMockUniversalClient creates a new mock instance
func NewMockUniversalClient(ctrl *gomock.Controller) *MockUniversalClient {
	mock := &MockUniversalClient{ctrl: ctrl}
	mock.recorder = &MockUniversalClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockUniversalClient) EXPECT() *MockUniversalClientMockRecorder {
	return m.recorder
}

// Append mocks base method
func (m *MockUniversalClient) Append(arg0, arg1 string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Append", arg0, arg1)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// Append indicates an expected call of Append
func (mr *MockUniversalClientMockRecorder) Append(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Append", reflect.TypeOf((*MockUniversalClient)(nil).Append), arg0, arg1)
}

// BLPop mocks base method
func (m *MockUniversalClient) BLPop(arg0 time.Duration, arg1 ...string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BLPop", varargs...)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

(这里省略3000多行....)

```

我们的业务代码是这样的

```
//storage.go
package storage

import (
	"github.com/go-redis/redis"
	"time"
) 
  
type Storage interface { 
	Set(key, val string, expiration time.Duration) error
	Get(key string) (val string,  err error)
}

type RedisStorage struct {
	redisCli redis.UniversalClient
}

func NewRedisStorage(cli redis.UniversalClient) Storage {
	return &RedisStorage{redisCli:cli}
}

func (s *RedisStorage) Set(key, val string, expiration time.Duration) error {
	return  s.redisCli.Set(key, val, expiration).Err()
}

func (s *RedisStorage) Get(key string) (val string,  err error) {
	return s.redisCli.Get(key).Result()
}

```

下面是测试RedisStorage的代码
```
//storage_test.go
package storage

import (
	"github.com/go-redis/redis"
	"github.com/golang/mock/gomock"
	"github.com/liyue201/graceful-go/demo/02.3/mock"
	"testing"
	"time"
) 
     
func Test_RedisStorage(t *testing.T)  {
	mockCtl := gomock.NewController(t)
	defer mockCtl.Finish()
	client := mock.NewMockUniversalClient(mockCtl)

	key := "aaaaa"
	val := "bbbbb" 

	expectSetResult := redis.NewStatusResult(val, nil)
	client.EXPECT().Set(key, val, time.Second).Return(expectSetResult)

	expectGetResult  := redis.NewStringResult(val, nil)
	client.EXPECT().Get(key).Return(expectGetResult)

	storage := NewRedisStorage(client)

	err := storage.Set(key, val, time.Second)
	if err != nil{
		t.Error(err)
		return
	}

	ret, err :=  storage.Get(key)
	if err != nil{
		t.Error(err)
		return
	}

	t.Logf("ret=%v", ret)

	if ret != val {
		t.Errorf("expect %v, but got %v",val, ret)
	}
}
``

这个例子跟上一节的区别是上一节mock的是Storage，这里是mock更底层的Redis。之所以可以这样做是因为这个redis客户端暴露了UniversalClient这个抽象的interface{}，而不是一个struct的指针，也是遵循了依赖倒置原则。
